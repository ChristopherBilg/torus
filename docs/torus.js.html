<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>torus.js annotated source</title>
    <link rel="stylesheet" href="main.css">
</head>

<body>
    <main>
        <div class="line">
            <div class="doc">
                <h1>torus.js <span class="fade">annotated source</span></h1>
                <em><a class="back" href="./">Back to index</a></em>
            </div>
            <pre></pre>
        </div>
        <div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1</strong>// @begindebug</pre></div>
<div class="line"><div class="doc"><p>These utility functions enable rich debugging statements
during development, when using the development build
(<code>dist/torus.dev.js</code>). These give you hierarchical information
about what components are being rendered, and how.</p>
</div><pre class="source javascript"><strong class="lineNumber">6</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber"></strong></pre></div>
<div class="line"><div class="doc"><p>Flag to enable rich debugging during renders</p>
</div><pre class="source javascript"><strong class="lineNumber">8</strong>const DEBUG_RENDER = true;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">9</strong></pre></div>
<div class="line"><div class="doc"><p>Repeat a string <code>count</code> times. Used to indent in <code>render_debug</code>.</p>
</div><pre class="source javascript"><strong class="lineNumber">11</strong>const repeat = (str, count) =&#62; {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">12</strong>    let s = '';</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">13</strong>    while (count -- &#62; 0) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">14</strong>        s += str;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">15</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">16</strong>    return s;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">17</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">18</strong></pre></div>
<div class="line"><div class="doc"><p>Main rich debug logger function. <code>render_debug()</code> depends on
the <code>render_stack</code> counter in our rendering algorithm to
figure out how deep in the render tree we are, and indent
the message to the level appropriate to our place in the
render tree.</p>
</div><pre class="source javascript"><strong class="lineNumber">24</strong>const render_debug = (msg, header = false) =&#62; {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">25</strong>    if (DEBUG_RENDER) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">26</strong>        if (header) {</pre></div>
<div class="line"><div class="doc"><p>We want to pull forward headers in front
of their section contents, so we de-indent 1.</p>
</div><pre class="source javascript"><strong class="lineNumber">29</strong>            const prefix = repeat('\t', render_stack - 1);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">30</strong>            console.log('%c' + prefix + msg, 'font-weight: bold');</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">31</strong>        } else {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">32</strong>            const prefix = repeat('\t', render_stack);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">33</strong>            console.log(prefix + msg);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">34</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">35</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">36</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">37</strong></pre></div>
<div class="line"><div class="doc"><p>Helper function for debugging logs where we want to print
a JDOM node in the most appropriate way, depending on type.</p>
</div><pre class="source javascript"><strong class="lineNumber">40</strong>const printNode = node =&#62; {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">41</strong>    if (node === null) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">42</strong>        return '&#60;!----&#62;';</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">43</strong>    } else if (node.tag) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">44</strong>        return `&#60;${node.tag.toLowerCase()}&#62;`;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">45</strong>    } else if (node.tagName) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">46</strong>        return `&#60;${node.tagName.toLowerCase()}&#62;`;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">47</strong>    } else if (typeof node === 'string' || typeof node === 'number') {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">48</strong>        return `"${node}"`;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">49</strong>    } else if (node.nodeType === 3) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">50</strong>        return `text node "${node.data}"`;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">51</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">52</strong>    return node.toString();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">53</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">54</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">55</strong>// @enddebug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">56</strong></pre></div>
<div class="line"><div class="doc"><p>A global counter for how deep we are in our render tree.
0 indicates that we aren&#39;t in the middle of rendering.</p>
</div><pre class="source javascript"><strong class="lineNumber">59</strong>let render_stack = 0;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">60</strong></pre></div>
<div class="line"><div class="doc"><p>Shortcut utility function to check if a given name is
bound to something that&#39;s an actual object (not just null).
We perform the <code>null</code> check first because that&#39;s faster.</p>
</div><pre class="source javascript"><strong class="lineNumber">64</strong>const isObject = obj =&#62; obj !== null &#38;&#38; typeof obj === 'object';</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">65</strong></pre></div>
<div class="line"><div class="doc"><p><code>normalizeJDOM</code> takes a JDOM object (dictionary) and modifies
it in place so it has the default JDOM properties, and we don&#39;t
have to complicate our rendering code by checking for nulls with
every key access into our serialized virtual DOM.
Note that we don&#39;t check <code>isObject(jdom)</code> here. We assume
only valid objects are passed in to &#39;normalize&#39;, which is true
in our usage so far. <code>normalizeJDOM</code> is a hot path in rendering,
so we need it as fast as it can be.</p>
</div><pre class="source javascript"><strong class="lineNumber">74</strong>const normalizeJDOM = jdom =&#62; {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">75</strong>    if (jdom.attrs === undefined) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">76</strong>        jdom.attrs = {};</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">77</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">78</strong>    if (jdom.events === undefined) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">79</strong>        jdom.events = {};</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">80</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">81</strong>    if (jdom.children === undefined) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">82</strong>        jdom.children = [];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">83</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">84</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">85</strong></pre></div>
<div class="line"><div class="doc"><p>Quick shorthand to normalize either 1. a single value or 2. an array
of values into an array of values. This is useful because JDOM
accepts either into things like <code>attrs.class</code> and <code>events.&lt;name&gt;</code>.</p>
</div><pre class="source javascript"><strong class="lineNumber">89</strong>const arrayNormalize = data =&#62; Array.isArray(data) ? data : [data];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">90</strong></pre></div>
<div class="line"><div class="doc"><p>We use comment nodes as placeholder nodes because they&#39;re lightweight
and invisible.</p>
</div><pre class="source javascript"><strong class="lineNumber">93</strong>const tmpNode = () =&#62; document.createComment('');</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">94</strong></pre></div>
<div class="line"><div class="doc"><p><code>opQueue</code> is a global queue of node-level operations to be performed.
These are calculated during the diff, but because operations touching the
page DOM are expensive, we defer them until the end of a render pass
and run them all at once, asynchronously. Each item in the queue is an array
that starts with an opcode (one of the three below), and is followed
by the list of arguments the operation takes. We render all operations in the queue
to the DOM before the browser renders the next frame.</p>
</div><pre class="source javascript"><strong class="lineNumber">102</strong>let opQueue = [];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">103</strong>const OP_APPEND = 0; // append, parent, new</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">104</strong>const OP_REMOVE = 1; // remove, parent, old</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">105</strong>const OP_REPLACE = 2; // replace, old, new</pre></div>
<div class="line"><div class="doc"><p>This is a stubbed <code>parentNode</code>. See below in <code>runDOMOperations</code> for why this exists.</p>
</div><pre class="source javascript"><strong class="lineNumber">107</strong>const STUB_PARENT = {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">108</strong>    replaceChild: () =&#62; {},</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">109</strong>};</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">110</strong></pre></div>
<div class="line"><div class="doc"><p><code>runDOMOperations</code> works through the <code>opQueue</code> and performs each
DOM operation in order they were queued. rDO is called when the reconciler
(<code>render</code>) reaches the bottom of a render stack (when it&#39;s done reconciling
the diffs in a root-level JDOM node of a component).</p>
</div><pre class="source javascript"><strong class="lineNumber">115</strong>function runDOMOperations() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber"></strong></pre></div>
<div class="line"><div class="doc"><p>This function is written to avoid any potential reconciliation conflicts.
There are two risks to mitigate: 1. attempting insert a node
that is already in the DOM, and 2. attempting remove a node that isn&#39;t
in the DOM. Both will result in inconsistent DOM state and break the renderer.
To avoid this, first, we remove all children and add placeholders where they
ought to be replaced. Then, in a second loop, we add any children that need
to be added and replace placeholders. Thus, no children will be inadvertently removed
and no wrong node will be removed.</p>
</div><pre class="source javascript"><strong class="lineNumber">124</strong>    const len = opQueue.length;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">125</strong>    for (let i = 0; i &#60; len; i ++) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">126</strong>        const next = opQueue[i];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">127</strong>        const op = next[0];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">128</strong>        if (op === OP_REMOVE) {</pre></div>
<div class="line"><div class="doc"><p>Remove all children that should be</p>
</div><pre class="source javascript"><strong class="lineNumber">130</strong>            next[1].removeChild(next[2]);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">131</strong>        } else if (op === OP_REPLACE) {</pre></div>
<div class="line"><div class="doc"><p>For the ones queued to for being replaced,
put in a placeholder node, and queue that up instead.</p>
</div><pre class="source javascript"><strong class="lineNumber">134</strong>            const oldNode = next[1];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">135</strong>            const tmp = tmpNode();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">136</strong>            const parent = oldNode.parentNode;</pre></div>
<div class="line"><div class="doc"><p>Sometimes, the given node will be a standalone node
(like the root of an unmounted component) and will have no <code>parentNode</code>.
In these rare cases, it&#39;s best for performance to just set the parent to a stub
with a no-op <code>replaceChild</code>. Trying to check for edge cases later each time is a
performance penalty, since this is a very rare case.</p>
</div><pre class="source javascript"><strong class="lineNumber">142</strong>            if (parent !== null) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">143</strong>                parent.replaceChild(tmp, oldNode);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">144</strong>                next[1] = tmp;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">145</strong>                next[3] = parent;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">146</strong>            } else {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">147</strong>                next[3] = STUB_PARENT;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">148</strong>            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">149</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">150</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">151</strong>    for (let i = 0; i &#60; len; i ++) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">152</strong>        const next = opQueue[i];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">153</strong>        const op = next[0];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">154</strong>        if (op === OP_APPEND) {</pre></div>
<div class="line"><div class="doc"><p>Add any node that need to be added</p>
</div><pre class="source javascript"><strong class="lineNumber">156</strong>            next[1].appendChild(next[2]);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">157</strong>        } else if (op === OP_REPLACE) {</pre></div>
<div class="line"><div class="doc"><p>Replace placeholders with correct nodes. This is
equivalent to <code>parent.replaceChild(newNode, oldNode)</code></p>
</div><pre class="source javascript"><strong class="lineNumber">160</strong>            next[3].replaceChild(next[2], next[1]);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">161</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">162</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">163</strong>    opQueue = [];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">164</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">165</strong></pre></div>
<div class="line"><div class="doc"><p>A function to compare event handlers in <code>render</code></p>
</div><pre class="source javascript"><strong class="lineNumber">167</strong>const diffEvents = (whole, sub, cb) =&#62; {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">168</strong>    for (const eventName of Object.keys(whole)) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">169</strong>        const wholeEvents = arrayNormalize(whole[eventName]);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">170</strong>        const subEvents = arrayNormalize(sub[eventName] || []);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">171</strong>        for (const handlerFn of wholeEvents) {</pre></div>
<div class="line"><div class="doc"><p>Sometimes, it&#39;s nice to be able to pass in non-function values to event
objects in JDOM, because we may be toggling the presence of an event listener
with a ternary expression, for example. We only attach function handlers here.</p>
</div><pre class="source javascript"><strong class="lineNumber">175</strong>            if (!subEvents.includes(handlerFn) &#38;&#38; typeof handlerFn === 'function') {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">176</strong>                cb(eventName, handlerFn);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">177</strong>            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">178</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">179</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">180</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">181</strong></pre></div>
<div class="line"><div class="doc"><p>Torus&#39;s virtual DOM rendering algorithm that manages all diffing,
updating, and efficient DOM access. <code>render</code> takes <code>node</code>, the previous
root node; <code>previous</code>, the previous JDOM; and <code>next</code>, the new JDOM;
and returns the new root node (potentially different from the old
root node.) Whenever a component is rendered, it calls <code>render</code>. This
rendering algorithm is recursive into child nodes. Despite not touching
the DOM, this is still one of the most expensive parts of rendering.</p>
</div><pre class="source javascript"><strong class="lineNumber">189</strong>const render = (node, previous, next) =&#62; {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">190</strong></pre></div>
<div class="line"><div class="doc"><p>This queues up a node to be inserted into a new slot in the
DOM tree. All queued replacements will flush to DOM at the end
of the render pass, from <code>runDOMOperations</code>.</p>
</div><pre class="source javascript"><strong class="lineNumber">194</strong>    const replacePreviousNode = newNode =&#62; {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">195</strong>        if (node &#38;&#38; node !== newNode) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">196</strong>            opQueue.push([OP_REPLACE, node, newNode]);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">197</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">198</strong>        node = newNode;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">199</strong>    };</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">200</strong></pre></div>
<div class="line"><div class="doc"><p>We&#39;re rendering a new node in the render tree. Increment counter.</p>
</div><pre class="source javascript"><strong class="lineNumber">202</strong>    render_stack ++;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">203</strong></pre></div>
<div class="line"><div class="doc"><p>We only do diff operations if the previous and next items are not the same.</p>
</div><pre class="source javascript"><strong class="lineNumber">205</strong>    if (previous !== next) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber"></strong></pre></div>
<div class="line"><div class="doc"><p>If we need to render a null (comment) node,
create and insert a comment node. This might seem
silly, but it keeps the DOM consistent between
renders and makes diff simpler.</p>
</div><pre class="source javascript"><strong class="lineNumber">210</strong>        if (next === null) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">211</strong>            // @begindebug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">212</strong>            if (node === undefined) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">213</strong>                render_debug('Add comment node');</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">214</strong>            } else {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">215</strong>                render_debug(`Replace previous node ${printNode(previous)} with comment node`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">216</strong>            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">217</strong>            // @enddebug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">218</strong>            replacePreviousNode(tmpNode());</pre></div>
<div class="line"><div class="doc"><p>If we&#39;re rendering a string or raw number,
convert it into a string and add a TextNode.</p>
</div><pre class="source javascript"><strong class="lineNumber">221</strong>        } else if (typeof next === 'string' || typeof next === 'number') {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">222</strong>            // @begindebug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">223</strong>            if (node === undefined) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">224</strong>                render_debug(`Add text node "${next}"`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">225</strong>            } else {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">226</strong>                render_debug(`Replace previous node ${printNode(previous)} with text node "${next}"`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">227</strong>            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">228</strong>            // @enddebug</pre></div>
<div class="line"><div class="doc"><p>If the previous node was also a text node, just replace the <code>.data</code>, which is
very fast (as of 5/2019 faster than <code>.nodeValue</code>, <code>.textContent</code>, and .<code>innerText</code>). Otherwise, create a new <code>TextNode</code>.</p>
</div><pre class="source javascript"><strong class="lineNumber">231</strong>            if (typeof previous === 'string' || typeof previous === 'number') {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">232</strong>                node.data = next;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">233</strong>            } else {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">234</strong>                replacePreviousNode(document.createTextNode(next));</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">235</strong>            }</pre></div>
<div class="line"><div class="doc"><p>If we need to render a literal DOM Node, just replace
the old node with the literal node.</p>
</div><pre class="source javascript"><strong class="lineNumber">238</strong>        } else if (next.appendChild !== undefined) { // check if next instanceof Node; fastest way is checking for presence of a non-getter property</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">239</strong>            // @begindebug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">240</strong>            if (node === undefined) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">241</strong>                render_debug(`Add literal element ${printNode(next)}`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">242</strong>            } else {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">243</strong>                render_debug(`Replace literal element ${printNode(previous)} with literal element ${printNode(next)}`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">244</strong>            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">245</strong>            // @enddebug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">246</strong>            replacePreviousNode(next);</pre></div>
<div class="line"><div class="doc"><p>If we&#39;re rendering an object literal, assume it&#39;s a serialized
JDOM dictionary. This is the meat of the algorithm.</p>
</div><pre class="source javascript"><strong class="lineNumber">249</strong>        } else { // next is a non-null object</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">250</strong>            // @debug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">251</strong>            render_debug(`Render pass for &#60;${next.tag}&#62;:`, true);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">252</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">253</strong>            if (</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">254</strong>                node === undefined</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">255</strong>                || !isObject(previous)</pre></div>
<div class="line"><div class="doc"><p>Check if previous instanceof Node; fastest way is checking for presence of a
non-getter property, like <code>appendChild</code>.</p>
</div><pre class="source javascript"><strong class="lineNumber">258</strong>                || (previous &#38;&#38; previous.appendChild !== undefined)</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber"></strong></pre></div>
<div class="line"><div class="doc"><p>If the tags differ, we assume the subtrees will be different
as well and just start a completely new element. This is efficient
in practice, reduces the time complexity of the algorithm, and
an optimization shared with React&#39;s reconciler.</p>
</div><pre class="source javascript"><strong class="lineNumber">263</strong>                || previous.tag !== next.tag</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">264</strong>            ) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">265</strong>                // @begindebug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">266</strong>                if (node === undefined) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">267</strong>                    render_debug(`Add &#60;${next.tag}&#62;`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">268</strong>                } else {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">269</strong>                    render_debug(`Replace previous node ${printNode(previous)} with &#60;${next.tag}&#62;`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">270</strong>                }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">271</strong>                // @enddebug</pre></div>
<div class="line"><div class="doc"><p>If the previous JDOM doesn&#39;t exist or wasn&#39;t JDOM, we&#39;re adding a completely
new node into the DOM. Stub an empty <code>previous</code>.</p>
</div><pre class="source javascript"><strong class="lineNumber">274</strong>                previous = {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">275</strong>                    tag: null,</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">276</strong>                };</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">277</strong>                replacePreviousNode(document.createElement(next.tag));</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">278</strong>            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">279</strong>            normalizeJDOM(previous);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">280</strong>            normalizeJDOM(next);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">281</strong></pre></div>
<div class="line"><div class="doc"><p>Compare and update attributes</p>
</div><pre class="source javascript"><strong class="lineNumber">283</strong>            for (const attrName of Object.keys(next.attrs)) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">284</strong>                const pAttr = previous.attrs[attrName];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">285</strong>                const nAttr = next.attrs[attrName]</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">286</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">287</strong>                if (attrName === 'class') {</pre></div>
<div class="line"><div class="doc"><p>JDOM can pass classes as either a single string
or an array of strings, so we need to check for either
of those cases.</p>
</div><pre class="source javascript"><strong class="lineNumber">291</strong>                    const nextClass = nAttr;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber"></strong></pre></div>
<div class="line"><div class="doc"><p>Mutating <code>className</code> is faster than iterating through
<code>classList</code> objects if there&#39;s only one batch operation
for all class changes.</p>
</div><pre class="source javascript"><strong class="lineNumber">295</strong>                    if (Array.isArray(nextClass)) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">296</strong>                        // @begindebug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">297</strong>                        if (node.className !== nextClass.join(' ')) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">298</strong>                            render_debug(`Update class names for &#60;${next.tag}&#62; to "${nextClass.join(' ')}"`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">299</strong>                        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">300</strong>                        // @enddebug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">301</strong>                        node.className = nextClass.join(' ');</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">302</strong>                    } else {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">303</strong>                        // @begindebug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">304</strong>                        if (node.className !== nextClass) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">305</strong>                            render_debug(`Update class name for &#60;${next.tag}&#62; to ${nextClass}`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">306</strong>                        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">307</strong>                        // @enddebug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">308</strong>                        node.className = nextClass;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">309</strong>                    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">310</strong>                } else if (attrName === 'style') {</pre></div>
<div class="line"><div class="doc"><p>JDOM takes style attributes as a dictionary
rather than a string for API ergonomics, so we serialize
it differently than other attributes.</p>
</div><pre class="source javascript"><strong class="lineNumber">314</strong>                    const prevStyle = pAttr || {};</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">315</strong>                    const nextStyle = nAttr;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">316</strong></pre></div>
<div class="line"><div class="doc"><p>When we iterate through the key/values of a flat object like this,
you may be tempted to use <code>Object.entries()</code>. We use <code>Object.keys()</code> and lookups,
which is less idiomatic, but fast. This results in a measurable performance bump.</p>
</div><pre class="source javascript"><strong class="lineNumber">320</strong>                    for (const styleKey of Object.keys(nextStyle)) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">321</strong>                        if (nextStyle[styleKey] !== prevStyle[styleKey]) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">322</strong>                            // @debug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">323</strong>                            render_debug(`Set &#60;${next.tag}&#62; style ${styleKey}: ${nextStyle[styleKey]}`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">324</strong>                            node.style[styleKey] = nextStyle[styleKey];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">325</strong>                        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">326</strong>                    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">327</strong>                    for (const styleKey of Object.keys(prevStyle)) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">328</strong>                        if (nextStyle[styleKey] === undefined) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">329</strong>                            // @debug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">330</strong>                            render_debug(`Unsetting &#60;${next.tag}&#62; style ${styleKey}: ${prevStyle[styleKey]}`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">331</strong>                            node.style[styleKey] = '';</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">332</strong>                        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">333</strong>                    }</pre></div>
<div class="line"><div class="doc"><p>If an attribute is an IDL attribute, we set it
through JavaScript properties on the HTML element
and not <code>setAttribute()</code>. This is necessary for
properties like <code>value</code> and <code>indeterminate</code>.</p>
</div><pre class="source javascript"><strong class="lineNumber">338</strong>                } else if (attrName in node) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">339</strong>                    // @debug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">340</strong>                    render_debug(`Set &#60;${next.tag}&#62; property ${attrName} = ${nAttr}`);</pre></div>
<div class="line"><div class="doc"><p>We explicitly make a comparison here before setting, because setting reflected
HTML properties is <em>not idempotent</em> -- on some elements like audio, video, and iframe,
setting properties like src will call a setter that sometimes resets UI state in some
browsers. We must compare the new value to DOM directly and not a previous JDOM value,
because they differ sometimes when the DOM mutates from under Torus&#39;s control, like on a user input.
We also guard against cases where the DOM has a default value (like input.type) but
we want to still specify a value manually, by checking if <code>pAttr</code> was defined.</p>
</div><pre class="source javascript"><strong class="lineNumber">348</strong>                    if (node[attrName] !== nAttr || (pAttr === undefined &#38;&#38; pAttr !== nAttr)) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">349</strong>                        node[attrName] = nAttr;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">350</strong>                    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">351</strong>                } else {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">352</strong>                    if (pAttr !== nAttr) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">353</strong>                        // @debug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">354</strong>                        render_debug(`Set &#60;${next.tag}&#62; attribute "${attrName}" to "${nAttr}"`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">355</strong>                        node.setAttribute(attrName, nAttr);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">356</strong>                    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">357</strong>                }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">358</strong>            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">359</strong></pre></div>
<div class="line"><div class="doc"><p>For any attributes that were removed in the new JDOM,
also attempt to remove them from the DOM.</p>
</div><pre class="source javascript"><strong class="lineNumber">362</strong>            for (const attrName of Object.keys(previous.attrs)) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">363</strong>                if (next.attrs[attrName] === undefined) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">364</strong>                    if (attrName in node) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">365</strong>                        // @debug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">366</strong>                        render_debug(`Remove &#60;${next.tag} property ${attrName}`);</pre></div>
<div class="line"><div class="doc"><p><code>null</code> seems to be the default for most IDL attrs,
but even this isn&#39;t entirely consistent. This seems
like something we should fix as issues come up, not
preemptively search for a cross-browser solution.</p>
</div><pre class="source javascript"><strong class="lineNumber">371</strong>                        node[attrName] = null;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">372</strong>                    } else {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">373</strong>                        // @debug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">374</strong>                        render_debug(`Remove &#60;${next.tag}&#62; attribute ${attrName}`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">375</strong>                        node.removeAttribute(attrName);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">376</strong>                    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">377</strong>                }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">378</strong>            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">379</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">380</strong>            diffEvents(next.events, previous.events, (eventName, handlerFn) =&#62; {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">381</strong>                // @debug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">382</strong>                render_debug(`Set new ${eventName} event listener on &#60;${next.tag}&#62;`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">383</strong>                node.addEventListener(eventName, handlerFn);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">384</strong>            });</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">385</strong>            diffEvents(previous.events, next.events, (eventName, handlerFn) =&#62; {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">386</strong>                // @debug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">387</strong>                render_debug(`Remove ${eventName} event listener on &#60;${next.tag}&#62;`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">388</strong>                node.removeEventListener(eventName, handlerFn);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">389</strong>            });</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">390</strong></pre></div>
<div class="line"><div class="doc"><p>Render children recursively. These loops are also well optimized, since
it&#39;s a hot patch of code at runtime.
We memoize generated child nodes into this <code>previous._nodes</code> array
so we don&#39;t have to perform expensive, DOM-touching operations during reconciliation
to look up children of the current node in the next render pass. <code>nodeChildren</code>
will be updated alongside enqueued DOM mutation operations.
In the future, we may also look at optimizing more of the common cases of list diffs
as <a href="https://github.com/WebReflection/domdiff/blob/master/esm/index.js">domdiff</a> does,
before delving into a full iterative diff of two lists.</p>
</div><pre class="source javascript"><strong class="lineNumber">400</strong>            const prevChildren = previous.children;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">401</strong>            const nextChildren = next.children;</pre></div>
<div class="line"><div class="doc"><p>Memoize length lookups.</p>
</div><pre class="source javascript"><strong class="lineNumber">403</strong>            const prevLength = prevChildren.length;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">404</strong>            const nextLength = nextChildren.length;</pre></div>
<div class="line"><div class="doc"><p>Smaller way to check for &quot;if either nextLength or prevLength is greater than zero&quot;</p>
</div><pre class="source javascript"><strong class="lineNumber">406</strong>            if (nextLength + prevLength &#62; 0) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber"></strong></pre></div>
<div class="line"><div class="doc"><p>Initialize variables we&#39;ll need / reference throughout child reconciliation.</p>
</div><pre class="source javascript"><strong class="lineNumber">408</strong>                const nodeChildren = previous._nodes || [];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">409</strong>                const minLength = prevLength &#60; nextLength ? prevLength : nextLength;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">410</strong></pre></div>
<div class="line"><div class="doc"><p>&quot;sync&quot; the common sections of the two children lists.</p>
</div><pre class="source javascript"><strong class="lineNumber">412</strong>                let i = 0;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">413</strong>                for (; i &#60; minLength; i ++) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">414</strong>                    if (prevChildren[i] !== nextChildren[i]) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">415</strong>                        nodeChildren[i] = render(nodeChildren[i], prevChildren[i], nextChildren[i]);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">416</strong>                    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">417</strong>                }</pre></div>
<div class="line"><div class="doc"><p>If the new JDOM has more children than the old JDOM, we need to
add the extra children.</p>
</div><pre class="source javascript"><strong class="lineNumber">420</strong>                if (prevLength &#60; nextLength) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">421</strong>                    for (; i &#60; nextLength; i ++) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">422</strong>                        // @begindebug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">423</strong>                        if (nextChildren[i].tagName) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">424</strong>                            render_debug(`Add child ${printNode(nextChildren[i])}`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">425</strong>                        } else if (nextChildren[i].tag) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">426</strong>                            render_debug(`Add child ${printNode(nextChildren[i])}`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">427</strong>                        } else {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">428</strong>                            render_debug(`Add child "${nextChildren[i]}"`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">429</strong>                        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">430</strong>                        // @enddebug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">431</strong>                        const newChild = render(undefined, undefined, nextChildren[i]);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">432</strong>                        opQueue.push([OP_APPEND, node, newChild]);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">433</strong>                        nodeChildren.push(newChild);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">434</strong>                    }</pre></div>
<div class="line"><div class="doc"><p>If the new JDOM has less than or equal number of children to the old
JDOM, we&#39;ll remove any stragglers.</p>
</div><pre class="source javascript"><strong class="lineNumber">437</strong>                } else {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">438</strong>                    for (; i &#60; prevLength; i ++) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">439</strong>                        // @begindebug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">440</strong>                        if (prevChildren[i].tagName) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">441</strong>                            render_debug(`Remove child ${printNode(prevChildren[i])}`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">442</strong>                        } else if (prevChildren[i].tag) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">443</strong>                            render_debug(`Remove child ${printNode(prevChildren[i])}`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">444</strong>                        } else {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">445</strong>                            render_debug(`Remove child "${prevChildren[i]}"`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">446</strong>                        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">447</strong>                        // @enddebug</pre></div>
<div class="line"><div class="doc"><p>If we need to remove a child element, removing
it from the DOM immediately might lead to race conditions.
instead, we add a placeholder and remove the placeholder
at the end.</p>
</div><pre class="source javascript"><strong class="lineNumber">452</strong>                        opQueue.push([OP_REMOVE, node, nodeChildren[i]]);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">453</strong>                    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">454</strong>                    nodeChildren.splice(nextLength, prevLength - nextLength);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">455</strong>                }</pre></div>
<div class="line"><div class="doc"><p>Mount <code>nodeChildren</code> onto the up-to-date JDOM, so the next
render pass can reference it.</p>
</div><pre class="source javascript"><strong class="lineNumber">458</strong>                next._nodes = nodeChildren;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">459</strong>            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">460</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">461</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">462</strong></pre></div>
<div class="line"><div class="doc"><p>We&#39;re done rendering the current node, so decrement the
render stack counter. If we&#39;ve reached the top of the
render tree, it&#39;s time to flush replaced nodes to the DOM
before the next frame.</p>
</div><pre class="source javascript"><strong class="lineNumber">467</strong>    if (-- render_stack === 0) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber"></strong></pre></div>
<div class="line"><div class="doc"><p><code>runDOMOperations()</code> can also be called completely asynchronously
with utilities like <code>requestIdleCallback</code>, <em>a la</em> Concurrent React,
for better responsiveness on larger component trees. This requires
a modification to Torus&#39;s architecture, so that each set of <code>DOMOperations</code>
tasks in the <code>opQueue</code> from one component&#39;s render call are flushed to
the DOM before the next component&#39;s <code>DOMOperations</code> begins, for consistency.
This can be achieved with a nested queue layer on top of <code>opQueue</code>.
Here, we omit concurrency support today because it&#39;s not a great necessity
where Torus is used.</p>
</div><pre class="source javascript"><strong class="lineNumber">477</strong>        runDOMOperations();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">478</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">479</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">480</strong>    return node;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">481</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">482</strong></pre></div>
<div class="line"><div class="doc"><p>Shorthand function for the default, empty event object in <code>Component</code>.</p>
</div><pre class="source javascript"><strong class="lineNumber">484</strong>const emptyEvent = () =&#62; {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">485</strong>    return {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">486</strong>        source: null,</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">487</strong>        handler: () =&#62; {},</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">488</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">489</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">490</strong></pre></div>
<div class="line"><div class="doc"><p>Torus&#39;s Component class</p>
</div><pre class="source javascript"><strong class="lineNumber">492</strong>class Component {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">493</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">494</strong>    constructor(...args) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">495</strong>        this.jdom = undefined;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">496</strong>        this.node = undefined;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">497</strong>        this.event = emptyEvent();</pre></div>
<div class="line"><div class="doc"><p>We call init() before render, because it&#39;s a common pattern
to set and initialize &quot;private&quot; fields in <code>this.init()</code> (at least
before the ES-next private fields proposal becomes widely supported.)
Frequently, rendering will require private values to be set correctly.</p>
</div><pre class="source javascript"><strong class="lineNumber">502</strong>        this.init(...args);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber"></strong></pre></div>
<div class="line"><div class="doc"><p>After we run <code>#init()</code>, we want to make sure that every constructed
component has a valid <code>#node</code> property. To be efficient, we only
render to set <code>#node</code> if it isn&#39;t already set yet.</p>
</div><pre class="source javascript"><strong class="lineNumber">506</strong>        if (this.node === undefined) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">507</strong>            this.render();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">508</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">509</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">510</strong></pre></div>
<div class="line"><div class="doc"><p><code>Component.from()</code> allows us to transform a pure function that
maps arguments to a JDOM tree, and promote it into a full-fledged
<code>Component</code> class we can compose and use anywhere.</p>
</div><pre class="source javascript"><strong class="lineNumber">514</strong>    static from(fn) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">515</strong>        return class FunctionComponent extends Component {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">516</strong>            init(...args) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">517</strong>                this.args = args;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">518</strong>            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">519</strong>            compose() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">520</strong>                return fn(...this.args);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">521</strong>            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">522</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">523</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">524</strong></pre></div>
<div class="line"><div class="doc"><p>The default <code>Component#init()</code> is guaranteed to always be a no-op method</p>
</div><pre class="source javascript"><strong class="lineNumber">526</strong>    init() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">527</strong>        // should be overridden</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">528</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">529</strong></pre></div>
<div class="line"><div class="doc"><p>Components usually subscribe to events from a Record, either a view model or
a model that maps to business logic. This is shorthand to access that.</p>
</div><pre class="source javascript"><strong class="lineNumber">532</strong>    get record() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">533</strong>        return this.event.source;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">534</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">535</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">536</strong>    bind(source, handler) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">537</strong>        this.unbind();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">538</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">539</strong>        if (source instanceof Evented) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">540</strong>            this.event = {source, handler};</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">541</strong>            source.addHandler(handler);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">542</strong>        } else {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">543</strong>            throw new Error(`cannot bind to ${source}, which is not an instance of Evented.`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">544</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">545</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">546</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">547</strong>    unbind() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">548</strong>        if (this.record) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">549</strong>            this.record.removeHandler(this.event.handler);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">550</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">551</strong>        this.event = emptyEvent();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">552</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">553</strong></pre></div>
<div class="line"><div class="doc"><p>We use <code>#remove()</code> to prepare to remove the component from our application
entirely. By default, it unsubscribes from all updates. However, the component
is still in the render tree -- that&#39;s something for the user to decide when to
hide.</p>
</div><pre class="source javascript"><strong class="lineNumber">558</strong>    remove() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">559</strong>        this.unbind();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">560</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">561</strong></pre></div>
<div class="line"><div class="doc"><p><code>#compose()</code> is our primary rendering API for components. By default, it renders
an invisible comment node.</p>
</div><pre class="source javascript"><strong class="lineNumber">564</strong>    compose() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">565</strong>        return null;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">566</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">567</strong></pre></div>
<div class="line"><div class="doc"><p><code>#preprocess()</code> is an API on the component to allow us to extend <code>Component</code> to give
it additional capabilities idiomatically. It consumes the result of <code>#compose()</code> and
returns JDOM to be used to actually render the component. See <code>Styled()</code> for a
usage example.</p>
</div><pre class="source javascript"><strong class="lineNumber">572</strong>    preprocess(jdom) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">573</strong>        return jdom;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">574</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">575</strong></pre></div>
<div class="line"><div class="doc"><p><code>#render()</code> is called to actually render the component again to the DOM,
and Torus assumes that it&#39;s called rarely, only when the component absolutely
must update. This obviates the need for something like React&#39;s <code>shouldComponentUpdate</code>.</p>
</div><pre class="source javascript"><strong class="lineNumber">579</strong>    render(data) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">580</strong>        // @debug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">581</strong>        render_debug(`Render Component: ${this.constructor.name}`, true);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">582</strong>        data = data || (this.record &#38;&#38; this.record.summarize())</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">583</strong>        const jdom = this.preprocess(this.compose(data), data);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">584</strong>        if (jdom === undefined) {</pre></div>
<div class="line"><div class="doc"><p>If the developer accidentally forgets to return the JDOM value from
compose, instead of leading to a cryptic DOM API error, show a more
friendly warning.</p>
</div><pre class="source javascript"><strong class="lineNumber">588</strong>            throw new Error(this.constructor.name + '.compose() returned undefined.');</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">589</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">590</strong>        try {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">591</strong>            this.node = render(this.node, this.jdom, jdom);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">592</strong>        } catch (e) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">593</strong>            /* istanbul ignore next: haven't found a reproducible error case that triggers this */</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">594</strong>            console.error('rendering error.', e);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">595</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">596</strong>        return this.jdom = jdom;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">597</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">598</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">599</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">600</strong></pre></div>
<div class="line"><div class="doc"><p>We keep track of unique class names already injected into the
page&#39;s stylesheet, so we don&#39;t do redundant style reconciliation.</p>
</div><pre class="source javascript"><strong class="lineNumber">603</strong>const injectedClassNames = new Set();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">604</strong></pre></div>
<div class="line"><div class="doc"><p>Global pointer to the stylesheet on the page that Torus uses to insert
new CSS rules. It&#39;s set the first time a styled component renders.</p>
</div><pre class="source javascript"><strong class="lineNumber">607</strong>let styledComponentSheet;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">608</strong></pre></div>
<div class="line"><div class="doc"><p>A weak (garbage-collected keys) cache for mapping styles objects to hashes
class names. If we use the <code>css</code> template tag or cache the styles object
generated in a component in other ways, it&#39;s substantially faster to do
a shallow comparison of styles objects and cache unique classnames than
to compare the styles objects deeply every time. This cache implements this
without a huge memory hit in the case of non-cached styles objects, because
<code>WeakMap</code>&#39;s keys are garbage collected.</p>
</div><pre class="source javascript"><strong class="lineNumber">616</strong>const INJECTED_STYLES_CACHE = new WeakMap();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">617</strong></pre></div>
<div class="line"><div class="doc"><p>Fast hash function to map a style rule to a very reasonably unique class name
that won&#39;t conflict with other classes on the page. Checks the styles cache first.</p>
</div><pre class="source javascript"><strong class="lineNumber">620</strong>const generateUniqueClassName = stylesObject =&#62; {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">621</strong>    if (!INJECTED_STYLES_CACHE.has(stylesObject)) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">622</strong>        // Modified from https://github.com/darkskyapp/string-hash/blob/master/index.js</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">623</strong>        const str = JSON.stringify(stylesObject);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">624</strong>        let i = str.length;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">625</strong>        let hash = 1989;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">626</strong>        while (i) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">627</strong>            hash = (hash * 13) ^ str.charCodeAt(-- i);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">628</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">629</strong>        INJECTED_STYLES_CACHE.set(stylesObject, '_torus' + (hash &#62;&#62;&#62; 0));</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">630</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">631</strong>    return INJECTED_STYLES_CACHE.get(stylesObject);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">632</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">633</strong></pre></div>
<div class="line"><div class="doc"><p>We have to construct lots of a{b} syntax in CSS, so here&#39;s a shorthand.</p>
</div><pre class="source javascript"><strong class="lineNumber">635</strong>const brace = (a, b) =&#62; a + '{' + b + '}';</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">636</strong></pre></div>
<div class="line"><div class="doc"><p>The meat of <code>Styled()</code>. This function maps an ergonomic, dictionary-based
set of CSS declarations to an array of CSS rules that can be inserted onto
the page stylesheet, and recursively resolves nested CSS, handles keyframes
and media queries, and parses other SCSS-like things.</p>
</div><pre class="source javascript"><strong class="lineNumber">641</strong>const rulesFromStylesObject = (selector, stylesObject) =&#62; {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">642</strong>    let rules = [];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">643</strong>    let selfDeclarations = '';</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">644</strong>    for (const prop of Object.keys(stylesObject)) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">645</strong>        const val = stylesObject[prop];</pre></div>
<div class="line"><div class="doc"><p>CSS declarations that start with &#39;@&#39; are globally namespaced
(like @keyframes and @media), so we need to treat them differently.</p>
</div><pre class="source javascript"><strong class="lineNumber">648</strong>        if (prop[0] === '@') {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">649</strong>            if (prop.startsWith('@media')) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">650</strong>                rules.push(brace(prop, rulesFromStylesObject(selector, val).join('')));</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">651</strong>            } else  { // @keyframes or @font-face</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">652</strong>                rules.push(brace(prop, rulesFromStylesObject('', val).join('')));</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">653</strong>            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">654</strong>        } else {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">655</strong>            if (typeof val === 'object') {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">656</strong>                const commaSeparatedProps = prop.split(',');</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">657</strong>                for (const p of commaSeparatedProps) {</pre></div>
<div class="line"><div class="doc"><p>SCSS-like syntax means we use &#39;&amp;&#39; to nest declarations about
the parent selector.</p>
</div><pre class="source javascript"><strong class="lineNumber">660</strong>                    if (p.includes('&#38;')) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">661</strong>                        const fullSelector = p.replace(/&#38;/g, selector);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">662</strong>                        rules = rules.concat(rulesFromStylesObject(fullSelector, val));</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">663</strong>                    } else {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">664</strong>                        rules = rules.concat(rulesFromStylesObject(selector + ' ' + p, val));</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">665</strong>                    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">666</strong>                }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">667</strong>            } else {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">668</strong>                selfDeclarations += prop + ':' + val + ';';</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">669</strong>            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">670</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">671</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">672</strong>    if (selfDeclarations) {</pre></div>
<div class="line"><div class="doc"><p>We unshift the self declarations to the beginning of the list of rules
instead of simply pushing it to the end, because we want the nested rules
to have precedence / override rules on self.</p>
</div><pre class="source javascript"><strong class="lineNumber">676</strong>        rules.unshift(brace(selector, selfDeclarations));</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">677</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">678</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">679</strong>    return rules;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">680</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">681</strong></pre></div>
<div class="line"><div class="doc"><p>Function called once to initialize a stylesheet for Torus
to use on every subsequent style render.</p>
</div><pre class="source javascript"><strong class="lineNumber">684</strong>const initSheet = () =&#62; {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">685</strong>    const styleElement = document.createElement('style');</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">686</strong>    styleElement.setAttribute('data-torus', '');</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">687</strong>    document.head.appendChild(styleElement);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">688</strong>    styledComponentSheet = styleElement.sheet;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">689</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">690</strong></pre></div>
<div class="line"><div class="doc"><p>The preprocessor on <code>Styled()</code> components call this to
make sure a given set of CSS rules for a component is inserted
into the page stylesheet, but only once for a unique set of rules.
We disambiguate by the class name, which is a hash of the CSS rules.</p>
</div><pre class="source javascript"><strong class="lineNumber">695</strong>const injectStylesOnce = stylesObject =&#62; {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">696</strong>    const className = generateUniqueClassName(stylesObject);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">697</strong>    let sheetLength = 0;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">698</strong>    if (!injectedClassNames.has(className)) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">699</strong>        if (!styledComponentSheet) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">700</strong>            initSheet();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">701</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">702</strong>        const rules = rulesFromStylesObject('.' + className, stylesObject);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">703</strong>        for (const rule of rules) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">704</strong>            // @debug</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">705</strong>            render_debug(`Add new CSS rule: ${rule}`);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">706</strong>            styledComponentSheet.insertRule(rule, sheetLength ++);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">707</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">708</strong>        injectedClassNames.add(className);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">709</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">710</strong>    return className;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">711</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">712</strong></pre></div>
<div class="line"><div class="doc"><p>Higher-order component to enable styling for any Component class.</p>
</div><pre class="source javascript"><strong class="lineNumber">714</strong>const Styled = Base =&#62; {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">715</strong>    return class extends Base {</pre></div>
<div class="line"><div class="doc"><p>In a styled component, the <code>#styles()</code> method is passed in
the same data as <code>#compose()</code>, and returns a JSON of nested CSS.</p>
</div><pre class="source javascript"><strong class="lineNumber">718</strong>        styles() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">719</strong>            return {};</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">720</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">721</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">722</strong>        preprocess(jdom, data) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">723</strong>            if (isObject(jdom)) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">724</strong>                jdom.attrs = jdom.attrs || {};</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">725</strong>                jdom.attrs.class = arrayNormalize(jdom.attrs.class || []);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">726</strong>                jdom.attrs.class.push(injectStylesOnce(this.styles(data)));</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">727</strong>            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">728</strong>            return jdom;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">729</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">730</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">731</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">732</strong></pre></div>
<div class="line"><div class="doc"><p>Torus&#39;s generic List implementation, based on Stores.
React and similar virtual-dom view libraries depend on <a href="https://reactjs.org/docs/reconciliation.html">key-based
reconciliation</a> during render
to efficiently render children of long lists. Torus doesn&#39;t (yet) have a key-aware
reconciler in the diffing algorithm, but <code>List</code>&#39;s design obviates the need for keys.
Rather than giving the renderer a flat virtual DOM tree to render, <code>List</code>
instantiates each individual item component and hands them off to the renderer as full
DOM Node elements, so each list item manages its own rendering, and the list component
only worries about displaying the list wrapper and a flat list of children items.</p>
</div><pre class="source javascript"><strong class="lineNumber">742</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">743</strong>class List extends Component {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">744</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">745</strong>    get itemClass() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">746</strong>        return Component; // default value, should be overridden</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">747</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">748</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">749</strong>    init(store, ...itemData) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">750</strong>        this.store = store;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">751</strong>        this.items = new Map();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">752</strong>        this.filterFn = null;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">753</strong>        this.itemData = itemData;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">754</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">755</strong>        this.bind(this.store, () =&#62; this.itemsChanged());</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">756</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">757</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">758</strong>    itemsChanged() {</pre></div>
<div class="line"><div class="doc"><p>For every record in the store, if it isn&#39;t already in
<code>this.items</code>, add it and its view; if any were removed,
also remove it from <code>this.items</code>.</p>
</div><pre class="source javascript"><strong class="lineNumber">762</strong>        const data = this.store.summarize();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">763</strong>        const items = this.items;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">764</strong>        for (const record of items.keys()) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">765</strong>            if (!data.includes(record)) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">766</strong>                items.get(record).remove();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">767</strong>                items.delete(record);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">768</strong>            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">769</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">770</strong>        for (const record of data) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">771</strong>            if (!items.has(record)) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">772</strong>                items.set(</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">773</strong>                    record,</pre></div>
<div class="line"><div class="doc"><p>We pass a callback that takes a record and removes it from
the list&#39;s store. It&#39;s common in UIs for items to have a button
that removes the item from the list, so this callback is passed
to the item component constructor to facilitate that pattern.</p>
</div><pre class="source javascript"><strong class="lineNumber">778</strong>                    new this.itemClass(</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">779</strong>                        record,</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">780</strong>                        () =&#62; this.store.remove(record),</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">781</strong>                        ...this.itemData</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">782</strong>                    )</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">783</strong>                );</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">784</strong>            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">785</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">786</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">787</strong>        let sorter = [...items.entries()];</pre></div>
<div class="line"><div class="doc"><p>Sort by the provided filter function if there is one</p>
</div><pre class="source javascript"><strong class="lineNumber">789</strong>        if (this.filterFn !== null) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">790</strong>            sorter = sorter.filter(item =&#62; this.filterFn(item[0]));</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">791</strong>        }</pre></div>
<div class="line"><div class="doc"><p>Sort the list the way the associated Store is sorted.</p>
</div><pre class="source javascript"><strong class="lineNumber">793</strong>        sorter.sort((a, b) =&#62; data.indexOf(a[0]) - data.indexOf(b[0]));</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">794</strong></pre></div>
<div class="line"><div class="doc"><p>Store the new items in a new (insertion-ordered) Map at this.items</p>
</div><pre class="source javascript"><strong class="lineNumber">796</strong>        this.items = new Map(sorter);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">797</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">798</strong>        this.render();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">799</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">800</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">801</strong>    filter(filterFn) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">802</strong>        this.filterFn = filterFn;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">803</strong>        this.itemsChanged();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">804</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">805</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">806</strong>    unfilter() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">807</strong>        this.filterFn = null;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">808</strong>        this.itemsChanged();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">809</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">810</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">811</strong>    get components() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">812</strong>        return [...this];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">813</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">814</strong></pre></div>
<div class="line"><div class="doc"><p><code>List#nodes</code> returns the HTML nodes for each of its item
views, sorted in order. Designed to make writing <code>#compose()</code> easier.</p>
</div><pre class="source javascript"><strong class="lineNumber">817</strong>    get nodes() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">818</strong>        return this.components.map(item =&#62; item.node);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">819</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">820</strong></pre></div>
<div class="line"><div class="doc"><p>This iterator is called when JavaScript requests an iterator from a list,
e.g. when <code>for (const _ of someList)</code> is run.</p>
</div><pre class="source javascript"><strong class="lineNumber">823</strong>    [Symbol.iterator]() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">824</strong>        return this.items.values();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">825</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">826</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">827</strong>    remove() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">828</strong>        super.remove();</pre></div>
<div class="line"><div class="doc"><p>When we remove a list, we also want to call <code>remove()</code> on each
child components.</p>
</div><pre class="source javascript"><strong class="lineNumber">831</strong>        for (const c of this.items.values()) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">832</strong>            c.remove();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">833</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">834</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">835</strong></pre></div>
<div class="line"><div class="doc"><p>By default, just render the children views in a <code>&lt;ul/&gt;</code></p>
</div><pre class="source javascript"><strong class="lineNumber">837</strong>    compose() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">838</strong>        return {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">839</strong>            tag: 'ul',</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">840</strong>            children: this.nodes,</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">841</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">842</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">843</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">844</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">845</strong></pre></div>
<div class="line"><div class="doc"><p>Higher-order component to create a list component for a given
child item component.</p>
</div><pre class="source javascript"><strong class="lineNumber">848</strong>const ListOf = itemClass =&#62; {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">849</strong>    return class extends List {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">850</strong>        get itemClass() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">851</strong>            return itemClass;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">852</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">853</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">854</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">855</strong></pre></div>
<div class="line"><div class="doc"><p>A base class for evented data stores. Not exposed to the public API, but
all observables in Torus inherit from <code>Evented</code>.</p>
</div><pre class="source javascript"><strong class="lineNumber">858</strong>class Evented {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">859</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">860</strong>    constructor() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">861</strong>        this.handlers = new Set();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">862</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">863</strong></pre></div>
<div class="line"><div class="doc"><p>Base, empty implementation of <code>#summarize()</code> which is overridden in all subclasses.
In subclasses, this returns the &quot;summary&quot; of the current state of the
event emitter as an object/array.</p>
</div><pre class="source javascript"><strong class="lineNumber">867</strong>    summarize /* istanbul ignore next */ () {}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">868</strong></pre></div>
<div class="line"><div class="doc"><p>Whenever something changes, we fire an event to all subscribed
listeners, with a summary of its state.</p>
</div><pre class="source javascript"><strong class="lineNumber">871</strong>    emitEvent() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">872</strong>        const summary = this.summarize();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">873</strong>        for (const handler of this.handlers) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">874</strong>            handler(summary);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">875</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">876</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">877</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">878</strong>    addHandler(handler) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">879</strong>        this.handlers.add(handler);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">880</strong>        handler(this.summarize());</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">881</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">882</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">883</strong>    removeHandler(handler) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">884</strong>        this.handlers.delete(handler);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">885</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">886</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">887</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">888</strong></pre></div>
<div class="line"><div class="doc"><p><code>Record</code> is Torus&#39;s unit of individual data source, used for view models and
Models from business logic.</p>
</div><pre class="source javascript"><strong class="lineNumber">891</strong>class Record extends Evented {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">892</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">893</strong>    constructor(id, data = {}) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">894</strong>        super();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">895</strong></pre></div>
<div class="line"><div class="doc"><p>We can create a Record by either passing in just the properties,
or an ID and a dictionary of props. We disambiguate here.</p>
</div><pre class="source javascript"><strong class="lineNumber">898</strong>        if (isObject(id)) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">899</strong>            data = id;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">900</strong>            id = null;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">901</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">902</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">903</strong>        this.id = id;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">904</strong>        this.data = data;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">905</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">906</strong></pre></div>
<div class="line"><div class="doc"><p>Setter for properties</p>
</div><pre class="source javascript"><strong class="lineNumber">908</strong>    update(data) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">909</strong>        Object.assign(this.data, data);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">910</strong>        this.emitEvent();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">911</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">912</strong></pre></div>
<div class="line"><div class="doc"><p>Getter</p>
</div><pre class="source javascript"><strong class="lineNumber">914</strong>    get(name) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">915</strong>        return this.data[name];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">916</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">917</strong></pre></div>
<div class="line"><div class="doc"><p>We summarize a Record by returning a dictionary of
all of its properties and the ID</p>
</div><pre class="source javascript"><strong class="lineNumber">920</strong>    summarize() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">921</strong>        return Object.assign(</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">922</strong>            {id: this.id},</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">923</strong>            this.data</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">924</strong>        );</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">925</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">926</strong></pre></div>
<div class="line"><div class="doc"><p>The JSON-serialized version of a Record is the same as its
summary, since it&#39;s a shallow data store with just plain properties.</p>
</div><pre class="source javascript"><strong class="lineNumber">929</strong>    serialize() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">930</strong>        return this.summarize();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">931</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">932</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">933</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">934</strong></pre></div>
<div class="line"><div class="doc"><p>A list of Records, represents a collection or a table</p>
</div><pre class="source javascript"><strong class="lineNumber">936</strong>class Store extends Evented {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">937</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">938</strong>    constructor(records = []) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">939</strong>        super();</pre></div>
<div class="line"><div class="doc"><p>Reset the store&#39;s contents with the given records</p>
</div><pre class="source javascript"><strong class="lineNumber">941</strong>        this.reset(records);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">942</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">943</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">944</strong>    get recordClass() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">945</strong>        return Record;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">946</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">947</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">948</strong>    get comparator() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">949</strong>        return null;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">950</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">951</strong></pre></div>
<div class="line"><div class="doc"><p>Create and return a new instance of the store&#39;s record from
the given data.</p>
</div><pre class="source javascript"><strong class="lineNumber">954</strong>    create(id, data) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">955</strong>        return this.add(new this.recordClass(id, data));</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">956</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">957</strong></pre></div>
<div class="line"><div class="doc"><p>Add a given record to this store, also called by <code>#create()</code>.</p>
</div><pre class="source javascript"><strong class="lineNumber">959</strong>    add(record) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">960</strong>        this.records.add(record);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">961</strong>        this.emitEvent();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">962</strong>        return record;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">963</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">964</strong></pre></div>
<div class="line"><div class="doc"><p>Remove a given record from the store.</p>
</div><pre class="source javascript"><strong class="lineNumber">966</strong>    remove(record) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">967</strong>        this.records.delete(record);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">968</strong>        this.emitEvent();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">969</strong>        return record;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">970</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">971</strong></pre></div>
<div class="line"><div class="doc"><p>This iterator is called when JavaScript requests an iterator from a store,
like when <code>for (const _ of someStore)</code> is run.</p>
</div><pre class="source javascript"><strong class="lineNumber">974</strong>    [Symbol.iterator]() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">975</strong>        return this.records.values();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">976</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">977</strong></pre></div>
<div class="line"><div class="doc"><p>Try to find a record with the given ID in the store,
and return it. Returns null if not found.</p>
</div><pre class="source javascript"><strong class="lineNumber">980</strong>    find(id) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">981</strong>        for (const record of this.records) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">982</strong>            if (record.id === id) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">983</strong>                return record;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">984</strong>            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">985</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">986</strong>        return null;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">987</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">988</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">989</strong>    reset(records) {</pre></div>
<div class="line"><div class="doc"><p>Internally, we represent the store as an unordered set.
we only order by comparator when we summarize. This prevents
us from having to perform sorting checks on every insert/update,
and is efficient as long as we don&#39;t re-render excessively.</p>
</div><pre class="source javascript"><strong class="lineNumber">994</strong>        this.records = new Set(records);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">995</strong>        this.emitEvent();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">996</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">997</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">998</strong>    summarize() {</pre></div>
<div class="line"><div class="doc"><p>The summary of a store is defined functionally. We just sort
the records in our store by the comparator (but we use a list
of pairs of cached comparators and records to be fast.</p>
</div><pre class="source javascript"><strong class="lineNumber">1002</strong>        return [...this.records].map(record =&#62; [</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1003</strong>            this.comparator ? this.comparator(record) : null,</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1004</strong>            record,</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1005</strong>        ]).sort((a, b) =&#62; {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1006</strong>            if (a[0] &#60; b[0]) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1007</strong>                return -1;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1008</strong>            } else if (a[0] &#62; b[0]) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1009</strong>                return 1;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1010</strong>            } else {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1011</strong>                return 0;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1012</strong>            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1013</strong>        }).map(o =&#62; o[1]);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1014</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1015</strong></pre></div>
<div class="line"><div class="doc"><p>To serialize a store, we serialize each record and put them
in a giant list.</p>
</div><pre class="source javascript"><strong class="lineNumber">1018</strong>    serialize() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1019</strong>        return this.summarize().map(record =&#62; record.serialize());</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1020</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1021</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1022</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1023</strong></pre></div>
<div class="line"><div class="doc"><p>Higher-order component to create a Store for a given
record class.</p>
</div><pre class="source javascript"><strong class="lineNumber">1026</strong>const StoreOf = recordClass =&#62; {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1027</strong>    return class extends Store {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1028</strong>        get recordClass() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1029</strong>            return recordClass;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1030</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1031</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1032</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1033</strong></pre></div>
<div class="line"><div class="doc"><p>Helper function for the router. It takes a route string
that contains parameters like, <code>/path/:param1/path/:param2</code>
and returns a regular expression to match that route
and a list of params in that route.</p>
</div><pre class="source javascript"><strong class="lineNumber">1038</strong>const routeStringToRegExp = route =&#62; {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1039</strong>    let match;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1040</strong>    const paramNames = [];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1041</strong>    while (match !== null) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1042</strong>        match = (/:\w+/).exec(route);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1043</strong>        if (match) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1044</strong>            const paramName = match[0];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1045</strong>            paramNames.push(paramName.substr(1));</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1046</strong>            route = route.replace(paramName, '(.+)');</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1047</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1048</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1049</strong>    return [new RegExp(route), paramNames];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1050</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1051</strong></pre></div>
<div class="line"><div class="doc"><p>Front-end router. A routing component can bind
to updates from the Router instead of a Record, and re-render
different subviews when the routes change.</p>
</div><pre class="source javascript"><strong class="lineNumber">1055</strong>class Router extends Evented {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1056</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1057</strong>    constructor(routes) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1058</strong>        super();</pre></div>
<div class="line"><div class="doc"><p>We parse the given dictionary of routes into three things:
the name of the route, the route regular expression, and
the list of params in that route.</p>
</div><pre class="source javascript"><strong class="lineNumber">1062</strong>        this.routes = Object.entries(routes)</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1063</strong>            .map(([name, route]) =&#62; [name, ...routeStringToRegExp(route)]);</pre></div>
<div class="line"><div class="doc"><p>Last matched route&#39;s information is cached here</p>
</div><pre class="source javascript"><strong class="lineNumber">1065</strong>        this.lastMatch = ['', null];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber"></strong></pre></div>
<div class="line"><div class="doc"><p>Whenever the browser pops the history state (i.e. when the user
goes back with the back button or forward with the forward button),
we need to route again.</p>
</div><pre class="source javascript"><strong class="lineNumber">1069</strong>        this._cb = () =&#62; this.route(location.pathname);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1070</strong>        window.addEventListener('popstate', this._cb);</pre></div>
<div class="line"><div class="doc"><p>Route the current URL, if it&#39;s already a deep link to a path.</p>
</div><pre class="source javascript"><strong class="lineNumber">1072</strong>        this._cb();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1073</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1074</strong></pre></div>
<div class="line"><div class="doc"><p>The &quot;summary&quot; of this Evented (components can bind to this object)
is the information about the last route.</p>
</div><pre class="source javascript"><strong class="lineNumber">1077</strong>    summarize() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1078</strong>        return this.lastMatch;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1079</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1080</strong></pre></div>
<div class="line"><div class="doc"><p>Click events from links can call <code>this.go()</code> with the destination URL
to trigger going to a new route without reloading the page. New routes
are only added to the session history if the route is indeed new.</p>
</div><pre class="source javascript"><strong class="lineNumber">1084</strong>    go(destination, {replace = false} = {}) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1085</strong>        if (window.location.pathname !== destination) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1086</strong>            if (replace) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1087</strong>                history.replaceState(null, document.title, destination);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1088</strong>            } else {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1089</strong>                history.pushState(null, document.title, destination);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1090</strong>            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1091</strong>            this.route(destination);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1092</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1093</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1094</strong></pre></div>
<div class="line"><div class="doc"><p>Main procedure to reconcile which of the defined route the current
location path matches, and dispatch the right event. Routes are checked
in order of declaration.</p>
</div><pre class="source javascript"><strong class="lineNumber">1098</strong>    route(path) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber"></strong></pre></div>
<div class="line"><div class="doc"><p>Match destination against the route regular expressions</p>
</div><pre class="source javascript"><strong class="lineNumber">1100</strong>        for (const [name, routeRe, paramNames] of this.routes) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1101</strong>            const match = routeRe.exec(path);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1102</strong>            if (match !== null) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1103</strong>                const result = {};</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1104</strong>                const paramValues = match.slice(1);</pre></div>
<div class="line"><div class="doc"><p>Given the matched values and parameter names,
build a dictionary of params that components can use
to re-render based on the route.</p>
</div><pre class="source javascript"><strong class="lineNumber">1108</strong>                paramNames.forEach((name, i) =&#62; result[name] = paramValues[i]);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1109</strong>                this.lastMatch = [name, result];</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1110</strong>                break;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1111</strong>            }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1112</strong>        }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1113</strong>        this.emitEvent();</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1114</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1115</strong></pre></div>
<div class="line"><div class="doc"><p>When we don&#39;t want the router to work anymore / stop listening / be gc&#39;d,
we can call <code>#remove()</code> to do just that.</p>
</div><pre class="source javascript"><strong class="lineNumber">1118</strong>    remove() {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1119</strong>        window.removeEventListener('popstate', this._cb);</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1120</strong>    }</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1121</strong></pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1122</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1123</strong></pre></div>
<div class="line"><div class="doc"><p>Torus exposes these public APIs</p>
</div><pre class="source javascript"><strong class="lineNumber">1125</strong>const exposedNames = {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber"></strong></pre></div>
<div class="line"><div class="doc"><p><code>render</code> isn&#39;t designed to be a public API and the API
might change, but it&#39;s exposed to make unit testing easier.</p>
</div><pre class="source javascript"><strong class="lineNumber">1128</strong>    render,</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1129</strong>    Component,</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1130</strong>    Styled,</pre></div>
<div class="line"><div class="doc"><p>Provide a default, <code>StyledComponent</code> class.</p>
</div><pre class="source javascript"><strong class="lineNumber">1132</strong>    StyledComponent: Styled(Component),</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1133</strong>    List,</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1134</strong>    ListOf,</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1135</strong>    Record,</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1136</strong>    Store,</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1137</strong>    StoreOf,</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1138</strong>    Router,</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1139</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1140</strong></pre></div>
<div class="line"><div class="doc"><p>If there is a global <code>window</code> object, bind API names to it.</p>
</div><pre class="source javascript"><strong class="lineNumber">1142</strong>/* istanbul ignore else */</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1143</strong>if (typeof window === 'object') {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1144</strong>    window.Torus = exposedNames;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1145</strong>}</pre></div>
<div class="line"><div class="doc"><p>Export public APIs CommonJS-style</p>
</div><pre class="source javascript"><strong class="lineNumber">1147</strong>/* istanbul ignore next */</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1148</strong>if (typeof module === 'object' &#38;&#38; module.exports) {</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1149</strong>    module.exports = exposedNames;</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1150</strong>}</pre></div>
<div class="line"><div class="doc"></div><pre class="source javascript"><strong class="lineNumber">1151</strong></pre></div>
    </main>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/github-gist.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
    <script>
        for (const el of document.querySelectorAll('.line pre')) {
            hljs.highlightBlock(el);
        }
    </script>
</body>

</html>
